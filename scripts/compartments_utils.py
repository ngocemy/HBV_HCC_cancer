# Visualisations related to compartments analysis
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gs
import matplotlib as mpl
import seaborn as sns
import itertools as it
import multiprocessing as mp
from math import factorial
from sklearn.decomposition import PCA
import scipy.spatial.distance as sdist
from statsmodels.stats.multitest import multipletests


def plot_eigens(comp_df, samples_df, chrom=None, out=None):
    """
    Plot compartments of an input given chromosome for all samples
    
    Parameters
    ----------
    comp_df : pandas.DataFrame
        Table of eigenvectors. Each row represents a bin from the Hi-C matrix,
        columns should be 'chrom', 'start', 'end' followed by one column per
        sample, where headers match the sample names in samples_df.
    samples_df : pandas.DataFrame
        Table of samples. Each row represents a sample. Columns should at least
        include be 'library' (the sample name) and population (2 values). 
    chrom : str
    out : bool
    """
    # Subset eigenvectors for the chromosome
    if chrom is not None:
        eigen = comp_df.loc[comp_df.chrom == chrom, :]
    else:
        eigen = comp_df
    # Draw figure to contain 1 panel per sample (row)
    _, axes = plt.subplots(samples_df.shape[0], 1)
    # Remove top and bottom margins around panels
    plt.subplots_adjust(hspace=0)
    libs = samples_df.sort_values(["population", "tissue"]).library
    pops = samples_df.sort_values(["population", "tissue"]).population
    tissue = samples_df.sort_values(["population", "tissue"]).tissue
    pop1, _ = samples_df.population.unique()
    # Draw panel for each sample
    for i, (lib, pop, tissue) in enumerate(zip(libs, pops, tissue)):
        # Draw two filled areas: one for each compartment
        compA = eigen[lib].copy()
        compA[compA <= 0] = 0
        compB = eigen[lib].copy()
        compB[compB > 0] = 0
        axes[i].fill_between(eigen["start"], 0, compA, color="g")
        axes[i].fill_between(eigen["start"], 0, compB, color="r")
        # Black horizontal axis at the center
        axes[i].axhline(0, c="black")
        # We don't need axis ticks eigenvectors are arbitrary, just show
        # the population of each sample
        axes[i].set_ylabel(tissue, rotation=0, fontsize=5)
        axes[i].set_yticks([])
        # Remove top frame line except for the first plot
        if i > 0:
            axes[i].spines["top"].set_visible(False)
        # Remove bottom frame line except for the last plot
        if i < (samples_df.shape[0] - 1):
            axes[i].set_xticks([])
            axes[i].spines["bottom"].set_visible(False)
        # Color ylabel according to population
        if pop == pop1:
            # Fancy blue from seaborn default palette
            lcol = "#1f77b4"
        else:
            # Fancy orange from seaborn default palette
            lcol = "#ff7f0e"
        axes[i].yaxis.label.set_color(lcol)
    plt.suptitle(f"Compartiments per individual, {chrom}")
    if out is None:
        plt.show()
    else:
        plt.savefig(out)


def get_css(
    selection,
    full_df,
    g1=[0, 1, 2],
    g2=[3, 4, 5],
    pvalue=False,
    metric="euclidean",
    max_boot=5000,
):
    """
    Computes a cluster separation score (CSS) metric as described in Jones et
    al. Nature, 2012.

    Parameters
    ----------
    selection : pandas.Series
        list of indices on which to work in full_df.
    full_df : pandas.DataFrame
        DataFrame containing all bins in the chromosome.
    g1 : list of ints
        List of column indices containing samples of group 1
    g2 : list of ints
        List of column indices containing samples of group 2
    pvalue : bool
        If True, returns a permutations-based p-value computed by comparing the CSS
        to CSS from all possible shuffling of sample labels.
    max_boot : int
        Maximum number of permutations allowed. If there are more permutations
        than max_boot, will bootstrap random combinations instead of shuffling.
    Returns
    -------
    float :
        Cluster separation score between g1 and g2 if pvalue is False, otherwise
        an empirical p-value generated by computing scores will all possible sample
        permutations.
    """
    df = full_df.iloc[selection, g1 + g2]
    m, n = len(g1), len(g2)
    # Build pairwise distance matrix of samples
    dist = sdist.squareform(sdist.pdist(np.array(df.T), metric=metric))
    # Get all possible g1 inter g2 combintations
    comb_grid = np.meshgrid(g1, g2)
    inter_comb = zip(comb_grid[0].reshape(-1), comb_grid[1].reshape(-1))
    # Compute mean intra and inter group distances
    mean_inter_dist = sum([dist[i, j] for i, j in inter_comb]) / (m * n)
    mean_g1_dist = sum([dist[i, j] for i, j in it.combinations(g1, 2)]) / (
        m ** 2 * (m - 1)
    )
    mean_g2_dist = sum([dist[i, j] for i, j in it.combinations(g2, 2)]) / (
        n ** 2 * (n - 1)
    )
    # Plug distances into CSS formula
    css = mean_inter_dist - (m + n) * mean_g1_dist + mean_g2_dist
    if pvalue:
        # Compute number of permutations required
        n_shuffles = int(factorial(n + m) / (factorial(n) * factorial(m)))
        if max_boot > n_shuffles:
            max_boot = n_shuffles
        # Initialize an array to store css from all possible combinations
        css_boot = np.zeros(int(n_shuffles))
        all_idx = np.array(range(n + m))
        bootstraps = np.random.choice(
            range(n_shuffles), size=max_boot, replace=False
        )
        for i, perm in enumerate(it.combinations(range(n + m), n)):
            if i not in bootstraps:
                continue
            g1_shuf = perm
            g2_shuf = all_idx[~np.isin(all_idx, perm)]
            # Get all possible g1 inter g2 combintations
            comb_grid = np.meshgrid(g1_shuf, g2_shuf)
            inter_comb = zip(
                comb_grid[0].reshape(-1), comb_grid[1].reshape(-1)
            )
            # Compute mean intra and inter group distances
            mean_inter_dist = sum([dist[i, j] for i, j in inter_comb]) / (
                m * n
            )
            mean_g1_dist = sum(
                [dist[i, j] for i, j in it.combinations(g1_shuf, 2)]
            ) / (m ** 2 * (m - 1))
            mean_g2_dist = sum(
                [dist[i, j] for i, j in it.combinations(g2_shuf, 2)]
            ) / (n ** 2 * (n - 1))
            # Plug distances into CSS formula
            css_boot[i] = (
                mean_inter_dist - (m + n) * mean_g1_dist + mean_g2_dist
            )
        # Compute p-value as proportion of random permutations with better score
        # than real case.
        pval = max(
            len(css_boot[css_boot >= css]) / len(css_boot), 1 / len(css_boot)
        )
        return pval
    return css


def css_chrom(args):
    """Function used by compute_compartments_div for parallelisation"""
    comp_df, chrom, win_size, g1_col_idx, g2_col_idx, ordered_cols = args
    chrom_df = comp_df.loc[comp_df.chrom == chrom, ordered_cols].reset_index(
        drop=True
    )
    idx = pd.Series(chrom_df.index.values)
    pval_chrom = idx.rolling(window=win_size).apply(
        lambda x: get_css(
            x, full_df=chrom_df, g1=g1_col_idx, g2=g2_col_idx, pvalue=True
        )
    )
    css_chrom = idx.rolling(window=win_size).apply(
        lambda x: get_css(
            x, full_df=chrom_df, g1=g1_col_idx, g2=g2_col_idx, pvalue=False
        )
    )
    print(f"{chrom} ({chrom_df.shape[0]} bins) processed...")
    return [chrom] * len(css_chrom), css_chrom.tolist(), pval_chrom.tolist()


def compute_compartments_div(
    eigen_df,
    samples_df,
    win_size=20,
    chrom_blacklist=["chrY"],
    max_boots=5000,
    cpus=12,
):
    """
    Compute a cluster separation score between the A/B compartments eigenvectors
    of two populations in sliding windows. This score gives a measure of inter
    populations differences after accounting for intra population variance. For
    Each window, compares the score to scores obtained by all possible permutations
    and computes an empirical p-value. After all sliding windows have been computed,
    p-values are corrected for multiple-testing using FDR with the Benjamini-Hochberg
    method.

    Parameters
    ----------
    eigen_df : pandas.DataFrame
    samples_df : pandas.DataFrame
    win_size : int
        Number of bins to use in each sliding window.
    chrom_blacklist : list of str
        List of chromosomes to skip. Will not be included in the results.
    max_boots : int
        Maximum number of random permutations when computing p-values.
    cpus : int
        Number of CPU cores to use for paralellisation.
    Returns
    -------
    css_out : pandas.DataFrame
        Table containing the result of sliding window computations. Columns are
        chrom, start, end, css, pval, qval, pop1_mean_eigen and pop2_mean_eigen.
        Where pop1 and pop2 are replaced by population names defined in samples_df.
    """

    comp_df = eigen_df.dropna(axis=0, how="any")
    pop1, pop2 = samples_df.population.unique()
    g1_cols = samples_df.library[samples_df.population == pop1]
    g2_cols = samples_df.library[samples_df.population == pop2]
    # Reorder columns by population and remember col indices for each pop
    ordered_cols = g1_cols.values.tolist() + g2_cols.values.tolist()
    g1_col_idx = list(range(len(g1_cols)))
    g2_col_idx = list(range(len(g1_cols), len(g2_cols) + len(g1_cols)))
    # Find all chromosomes in dataset (and conserve original order)
    chromosomes = comp_df.chrom.unique()
    # Remove chromosomes declared in blacklist
    chromosomes = chromosomes[~np.isin(chromosomes, chrom_blacklist)]
    # Initialize structure to receive cluster separation scores (CSS)
    css_genome = {}
    pool = mp.Pool(cpus)
    # For each chromosome, compute a CSS in sliding windows and append results
    mp_args = [
        [comp_df, chrom, win_size, g1_col_idx, g2_col_idx, ordered_cols]
        for chrom in chromosomes
    ]
    # Run one sliding window per chromosome in parallel
    css_res = pool.map(css_chrom, mp_args)
    css_genome["chr"] = np.concatenate([a[0] for a in css_res], axis=0)
    css_genome["css"] = np.concatenate([a[1] for a in css_res], axis=0)
    css_genome["pval"] = np.concatenate([a[2] for a in css_res], axis=0)
    css_genome = pd.DataFrame(css_genome)
    # Correct p-values for multiple testing using Benjamini Hochberg
    qval = css_genome.pval.copy()
    qval[~np.isnan(qval)] = multipletests(
        qval[~np.isnan(qval)], method="fdr_bh"
    )[1]
    css_genome["qval"] = qval
    # remove blacklisted chroms from comp_df
    comp_df = comp_df.loc[~np.isin(comp_df.chrom, chrom_blacklist), :]
    # Add genomic coordinates to the css df
    css_out = pd.concat(
        [
            comp_df.loc[:, ["chrom", "start", "end"]].reset_index(drop=True),
            css_genome.drop(labels="chr", axis=1).reset_index(drop=True),
        ],
        axis=1,
    )
    # get columns into clean order
    css_out = css_out.loc[:, ["chrom", "start", "end", "css", "pval", "qval"]]
    # Add mean compartment for each pop
    css_out[f"{pop1}_mean_eigen"] = np.nanmean(comp_df.loc[:, g1_cols], axis=1)
    css_out[f"{pop2}_mean_eigen"] = np.nanmean(comp_df.loc[:, g2_cols], axis=1)
    return css_out


def plot_compartments_div(df, out=None, win_size=20):
    """
    Generates multipanel figure to show divergence between compartments of two
    populations.

    Parameters
    ----------
    df : pandas.DataFrame
        Table containing pre-computed pvalues and corrected pvalues for each
        compartment bin. Columns should be: chrom, start, end, css, pval, qval,
        pop1_mean_eigen and pop2_mean_eigen. Where pop1 and pop2 should be population
        names.
    win_size : int
        Number of compartment bins that were used to compute each CSS window.
    out : str
        Output file where to save the figure. If None, figure is shown interactively
    """
    mpl.rcParams["axes.xmargin"] = 0
    mpl.rcParams["axes.ymargin"] = 0
    # WARNING: win_size_bp is approximate, since some values are NAs
    win_size_bp = win_size * (df.end[0] - df.start[0])
    chromosomes = df.chrom.unique()
    plt.figure(figsize=(24, 8))
    plt.subplots_adjust(hspace=0)
    gs1 = gs.GridSpec(2, 2, height_ratios=(8, 1), width_ratios=(5, 1))
    gs1.update(left=0.05, right=0.88, wspace=0.05)
    ax_genome = plt.subplot(gs1[0, :])
    ax_comp = plt.subplot(gs1[1, :], sharex=ax_genome)

    gs2 = gs.GridSpec(1, 1)
    gs2.update(left=0.92, right=0.98, hspace=0.05)
    ax_histo = plt.subplot(gs2[0, 0])
    # hist_ax.set_aspect('equal', adjustable='box')

    # ax_genome = plt.subplot(grid[0])
    # ax_histo = plt.subplot(grid[1])
    pcol1, pcol2 = df.columns[df.columns.str.endswith("_mean_eigen")]
    pop1, pop2 = pcol1.split("_")[0], pcol2.split("_")[0]
    df["cum_bp"] = (df.start + df.end) / 2
    start = 0
    for chrom in chromosomes:
        df.loc[df.chrom == chrom, "cum_bp"] += start
        ax_genome.axvline(np.min(df.cum_bp[df.chrom == chrom]), c="lightgrey")
        ax_comp.axvline(np.min(df.cum_bp[df.chrom == chrom]), c="lightgrey")
        start += np.max(df.start[df.chrom == chrom])

    # Plot -log10 corrected p-values along genome
    ax_genome.plot(df["cum_bp"], -np.log10(df["qval"]), linewidth=0.5)
    ax_genome.set_title(
        f"Cluster separation score for {pop1} vs {pop2} compartments"
    )
    ax_genome.set_xticks([])
    ax_genome.set_ylabel(
        f"-log10 q-value in {int(win_size_bp / 1000)}kb rolling windows"
    )
    # ax_genome.set_ylim([0, 2])
    ax_genome.axhline(y=-np.log10(0.05), ls=":")

    # Plot compartments of both pops
    eig2col = lambda x: "green" if x > 0 else "red"
    eig2grey = lambda x: "#888888" if x > 0 else "#555555"
    for r in df.iterrows():
        seg = r[1]
        # If compartments of both populations are identical for the bin, use
        # grey colors, if there is a switch, highlight with colors
        comp1, comp2 = (
            seg[pcol1] / abs(seg[pcol1]),
            seg[pcol2] / abs(seg[pcol2]),
        )
        colfun = eig2grey if comp1 == comp2 else eig2col
        # Plot compartment of pop1
        if not np.isnan(seg[pcol1]):
            rect = plt.Rectangle(
                xy=(seg["cum_bp"] - (win_size_bp / 2), 0),  # bottom-left coord
                width=win_size_bp,
                height=0.25,
                fill=True,
                color=colfun(seg[pcol1]),
            )
            ax_comp.add_patch(rect)
        # Plot comparmtent of pop2
        if not np.isnan(seg[pcol2]):
            rect = plt.Rectangle(
                xy=(seg["cum_bp"] - (win_size_bp / 2), 0.25),
                width=win_size_bp,
                height=0.25,
                fill=True,
                color=colfun(seg[pcol2]),
            )
            ax_comp.add_patch(rect)

    ax_comp.set_xlabel("Genomic position [bp]")
    ax_comp.set_ylim([0, 0.5])
    ax_comp.set_yticks([0.125, 0.375])
    ax_comp.set_yticklabels([pop1, pop2])
    ax_comp.use_sticky_edges = True
    # Plot distribution of pvalues after correction for multiple testing
    sns.violinplot(df["qval"], ax=ax_histo, orient="v")
    ax_histo.set_title("Distribution of BH \nFDR-corrected q-values")
    ax_histo.set_xlabel("q-values")
    ax_histo.set_ylabel("")
    if out is None:
        plt.show()
    else:
        plt.savefig(out)


def pca_compartments(comp_df, samples_df, out=None):
    """Show inter-sample distance based on eigenvectors"""
    pca = PCA(n_components=2)
    comp_mat = np.array(comp_df.iloc[:, 3:].dropna(axis=0, how="any")).T
    comp_pc = pca.fit(comp_mat)
    comp_df = pd.DataFrame(comp_pc.transform(comp_mat), columns=["PC1", "PC2"])
    comp_df["population"] = samples_df.population.values
    sns.set(style="ticks")
    var1, var2 = comp_pc.explained_variance_ratio_[:2]
    g = sns.relplot(x="PC1", y="PC2", hue="population", data=comp_df)
    plt.xlabel(f"PC1 ({round(100 * var1, 2):.2f} %)")
    plt.ylabel(f"PC2 ({round(100 * var2, 2):.2f} %)")
    plt.title("PCA on compartment eigenvectors of the Hi-C matrices")
    if out is None:
        plt.show()
    else:
        plt.savefig(out)

